---
import RootLayout from "@/layouts/RootLayout.astro";
import { SITE_METADATA } from '@/consts';
import { WORKSHOPS } from "@/data/workshops";

export const prerender = true;

const knowledge = {
  name: SITE_METADATA.author,
  role: "Developer Relations Professional",
  focus: "Developer experience, community building, and AI-powered developer tools.",
  book: {
    title: "Vector Search with JavaScript",
    description: "Build AI-powered search systems with JavaScript. Published by The Pragmatic Bookshelf.",
    link: "https://pragprog.com/titles/bgvector/vector-search-with-javascript/",
  },
  links: {
    email: SITE_METADATA.email,
    github: SITE_METADATA.github,
    linkedin: SITE_METADATA.linkedin,
    twitter: SITE_METADATA.twitter,
    youtube: SITE_METADATA.youtube,
    substack: SITE_METADATA.substack,
    sponsor: "https://github.com/sponsors/hummusonrails",
  },
  pages: {
    about: "/about",
    blog: "/blog",
    talks: "/talks",
    workshops: "/projects",
    book: "/book",
  },
  workshops: WORKSHOPS,
};

const suggestedPrompts = [
  "Give me a quick bio",
  "Show recent blog posts",
  "List the workshops",
  "Share recent talks",
  "How can I contact Ben?",
];
---

<RootLayout title={SITE_METADATA.title} description={SITE_METADATA.description}>
  <div class="chat-page">
    <div class="chat-thread" id="chat-thread">
      <div class="chat-empty" id="chat-empty">
        <p class="chat-empty-title">Ready when you are.</p>
        <p class="chat-empty-subtitle">Ask about Ben's work, writing, or speaking.</p>
        <div class="chat-suggestions">
          {suggestedPrompts.map((prompt) => (
            <button class="chat-suggestion" type="button" data-prompt={prompt}>
              {prompt}
            </button>
          ))}
        </div>
      </div>
    </div>

    <div class="chat-input-wrap">
      <form class="chat-input" id="chat-form">
        <label class="sr-only" for="chat-input">Ask about Ben's work</label>
        <input
          id="chat-input"
          name="prompt"
          type="text"
          autocomplete="off"
          placeholder="Ask anything"
        />
        <button id="chat-mic" type="button" class="chat-tool" aria-label="Voice input">
          mic
        </button>
        <button type="submit" class="chat-send" aria-label="Send message">
          <span>&gt;</span>
        </button>
      </form>
      <p class="chat-disclaimer">Responses are curated from Ben's public portfolio content.</p>
    </div>
  </div>

  <script is:inline define:vars={{ knowledge, suggestedPrompts }}>
    const setupChat = () => {
      const defaultPrompts = suggestedPrompts;
      const thread = document.getElementById('chat-thread');
      const form = document.getElementById('chat-form');
      const input = document.getElementById('chat-input');
      const emptyState = document.getElementById('chat-empty');
      const scrollContainer = document.querySelector('.chat-main-slot');
      const micButton = document.getElementById('chat-mic');

      if (!thread || !form || !input) {
        return;
      }

      if (form.dataset.bound === 'true') {
        return;
      }
      form.dataset.bound = 'true';

      const state = {
        posts: [],
        talks: [],
      };

      const includesAny = (value, keywords) =>
        keywords.some((word) => {
          if (word.includes(' ')) {
            return value.includes(word);
          }
          const re = new RegExp(`\\b${word}\\b`, 'i');
          return re.test(value);
        });

      const addMessage = (role, contentNode) => {
        if (emptyState) {
          emptyState.style.display = 'none';
        }
        const message = document.createElement('div');
        message.className = `chat-message chat-message-${role}`;

        const avatar = document.createElement('div');
        avatar.className = `chat-avatar chat-avatar-${role}`;
        avatar.textContent = role === 'assistant' ? 'BG' : 'You';

        const body = document.createElement('div');
        body.className = 'chat-message-content';
        body.appendChild(contentNode);

        message.appendChild(avatar);
        message.appendChild(body);
        thread.appendChild(message);
        if (scrollContainer) {
          scrollContainer.scrollTop = scrollContainer.scrollHeight;
        }
      };

      const addAssistantNote = (text) => {
        const container = document.createElement('div');
        container.appendChild(createParagraph(text, 'chat-footnote'));
        addMessage('assistant', container);
      };

      const createParagraph = (text, className = '') => {
      const p = document.createElement('p');
      if (className) {
        p.className = className;
      }
      p.textContent = text;
      return p;
      };

      const createList = (items) => {
      const list = document.createElement('ul');
      list.className = 'chat-list';
      items.forEach((item) => {
        const li = document.createElement('li');
        const link = document.createElement('a');
        link.className = 'chat-link';
        link.href = item.url;
        if (item.url.startsWith('http')) {
          link.target = '_blank';
          link.rel = 'noreferrer';
        }
        link.textContent = item.label;
        li.appendChild(link);
        if (item.description) {
          const span = document.createElement('span');
          span.className = 'chat-list-meta';
          span.textContent = item.description;
          li.appendChild(span);
        }
        list.appendChild(li);
      });
      return list;
      };

      const createSuggestions = (prompts) => {
      const wrapper = document.createElement('div');
      wrapper.className = 'chat-suggestions';
      prompts.forEach((prompt) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'chat-suggestion';
        button.dataset.prompt = prompt;
        button.textContent = prompt;
        wrapper.appendChild(button);
      });
      return wrapper;
      };

      const renderAssistantResponse = (response) => {
      const container = document.createElement('div');
      response.paragraphs.forEach((text, index) => {
        const className = index === 0 ? 'chat-lede' : '';
        container.appendChild(createParagraph(text, className));
      });
      if (response.items.length) {
        container.appendChild(createList(response.items));
      }
      if (response.footer) {
        container.appendChild(createParagraph(response.footer, 'chat-footnote'));
      }
      if (response.suggestions && response.suggestions.length) {
        container.appendChild(createSuggestions(response.suggestions));
      }
      addMessage('assistant', container);
      };

      const buildResponse = (inputText) => {
        const normalized = inputText.toLowerCase();

      if (includesAny(normalized, ['hello', 'hi', 'hey'])) {
        return {
          paragraphs: [
            `Hey! I'm ${knowledge.name}.`,
            'Ask about talks, workshops, blog posts, or the book.',
          ],
          items: [],
          footer: '',
          suggestions: defaultPrompts,
        };
      }

      if (includesAny(normalized, ['about', 'bio', 'background', 'who are you', 'who is'])) {
        return {
          paragraphs: [
            `${knowledge.name} is a ${knowledge.role}.`,
            knowledge.focus,
          ],
          items: [
            { label: 'Read the full bio', url: knowledge.pages.about, description: 'Long-form background and story.' },
          ],
          footer: 'Want highlights from recent talks or writing?',
          suggestions: ['Share recent talks', 'Show recent blog posts'],
        };
      }

      if (includesAny(normalized, ['book', 'vector', 'pragmatic'])) {
        return {
          paragraphs: [
            knowledge.book.title,
            knowledge.book.description,
          ],
          items: [
            { label: 'Get the book', url: knowledge.book.link, description: 'Pragmatic Bookshelf.' },
            { label: 'Book overview', url: knowledge.pages.book, description: 'Highlights and table of contents.' },
          ],
          footer: 'Want a sample chapter or topic breakdown?',
          suggestions: ['Show the table of contents', 'What does the book cover?'],
        };
      }

      if (includesAny(normalized, ['workshop', 'workshops', 'project', 'projects'])) {
        if (includesAny(normalized, ['ai search', 'vector', 'semantic'])) {
          const match = knowledge.workshops.find((workshop) =>
            workshop.title.toLowerCase().includes('vector search')
          );
          return {
            paragraphs: [
              'For AI search, this workshop is the best fit.',
            ],
            items: match
              ? [
                  {
                    label: match.title,
                    url: match.link,
                    description: match.description,
                  },
                ]
              : [],
            footer: 'Want a customized version for your team?',
            suggestions: ['Show the workshops', 'Talks about vector search'],
          };
        }

        if (includesAny(normalized, ['rust', 'stylus'])) {
          const rustWorkshops = knowledge.workshops.filter((workshop) =>
            workshop.title.toLowerCase().includes('rust') ||
            workshop.description.toLowerCase().includes('rust') ||
            workshop.title.toLowerCase().includes('stylus')
          );
          return {
            paragraphs: [
              'Here are the Rust-focused workshops.',
            ],
            items: rustWorkshops.map((workshop) => ({
              label: workshop.title,
              url: workshop.link,
              description: workshop.description,
            })),
            footer: 'Want something more advanced?',
            suggestions: ['Show the workshops', 'Talks about Rust'],
          };
        }
        return {
          paragraphs: [
            'Here are the hands-on workshops Ben teaches.',
          ],
          items: knowledge.workshops.map((workshop) => ({
            label: workshop.title,
            url: workshop.link,
            description: workshop.description,
          })),
          footer: 'Want a tailored workshop recommendation?',
          suggestions: ['Which workshop is best for AI search?', 'Show workshops on Rust'],
        };
      }

      if (includesAny(normalized, ['talk', 'talks', 'speaking', 'speaker', 'conference', 'recent talks'])) {
        if (!state.talks.length) {
          return {
            paragraphs: [
              'Loading the talks list right now.',
              'Try again in a moment or open the talks page.',
            ],
            items: [{ label: 'Browse talks', url: knowledge.pages.talks }],
            footer: '',
            suggestions: ['List recent talks'],
          };
        }
        return {
          paragraphs: [
            'Recent speaking engagements and conference sessions.',
          ],
          items: state.talks.slice(0, 6).map((talk) => ({
            label: talk.presentation,
            url: talk.link || knowledge.pages.talks,
            description: `${talk.conference} - ${new Date(talk.date).getFullYear()}`,
          })),
          footer: 'Want a specific topic or region?',
          suggestions: ['Talks about vector search', 'Talks in Europe'],
        };
      }

      if (includesAny(normalized, [
        'blog',
        'post',
        'posts',
        'writing',
        'article',
        'articles',
        'read next',
        'what should i read',
        'what should i read next',
        'recommend',
      ])) {
        if (!state.posts.length) {
          return {
            paragraphs: [
              'Fetching the latest posts.',
              'You can also open the blog archive.',
            ],
            items: [{ label: 'Open the blog', url: knowledge.pages.blog }],
            footer: '',
            suggestions: ['Show recent blog posts'],
          };
        }
        return {
          paragraphs: [
            'Here are the latest articles from the blog.',
          ],
          items: state.posts.slice(0, 6).map((post) => ({
            label: post.title,
            url: `/blog/${post.slug}`,
            description: 'Read the full post.',
          })),
          footer: 'Want posts on AI, DevRel, or community building?',
          suggestions: ['Posts about AI', 'Posts on developer relations'],
        };
      }

      if (includesAny(normalized, ['contact', 'email', 'reach', 'connect', 'hire'])) {
        return {
          paragraphs: [
            'Here are the best ways to reach Ben.',
          ],
          items: [
            { label: knowledge.links.email, url: `mailto:${knowledge.links.email}`, description: 'Primary email.' },
            { label: 'LinkedIn', url: knowledge.links.linkedin, description: 'Connect professionally.' },
            { label: 'GitHub', url: knowledge.links.github, description: 'Code and workshops.' },
          ],
          footer: 'Need a workshop or speaking inquiry? Include topic and event details.',
          suggestions: ['Book Ben for a talk', "Sponsor Ben's work"],
        };
      }

      if (includesAny(normalized, ['sponsor', 'support'])) {
        return {
          paragraphs: [
            "Want to support Ben's work?",
          ],
          items: [
            { label: 'Sponsor on GitHub', url: knowledge.links.sponsor, description: 'Monthly or one-time support.' },
          ],
          footer: 'Thank you for supporting the community!',
          suggestions: ['How else can I support?', 'Show the workshops'],
        };
      }

      if (includesAny(normalized, ['github', 'linkedin', 'twitter', 'youtube', 'substack'])) {
        return {
          paragraphs: [
            "Here are Ben's main channels.",
          ],
          items: [
            { label: 'GitHub', url: knowledge.links.github, description: 'Open source work.' },
            { label: 'LinkedIn', url: knowledge.links.linkedin, description: 'Professional updates.' },
            { label: 'Twitter', url: knowledge.links.twitter, description: 'Short-form commentary.' },
            { label: 'YouTube', url: knowledge.links.youtube, description: 'Video content.' },
            { label: 'Substack', url: knowledge.links.substack, description: 'Long-form newsletters.' },
          ],
          footer: 'Want a specific topic or channel?',
          suggestions: ['Show the blog', 'List recent talks'],
        };
      }

      return {
        paragraphs: [
          "I can help with Ben's writing, talks, workshops, book, or contact info.",
          'Try one of these prompts to get started.',
        ],
        items: [],
        footer: '',
        suggestions: defaultPrompts,
      };
      };

      const showTypingIndicator = () => {
        if (emptyState) {
          emptyState.style.display = 'none';
        }
        const indicator = document.createElement('div');
        indicator.className = 'chat-message chat-message-assistant chat-typing';
      indicator.dataset.typing = 'true';

      const avatar = document.createElement('div');
      avatar.className = 'chat-avatar chat-avatar-assistant';
      avatar.textContent = 'BG';

      const content = document.createElement('div');
      content.className = 'chat-message-content';

      const dots = document.createElement('div');
      dots.className = 'chat-typing-dots';
      dots.innerHTML = '<span></span><span></span><span></span>';

      content.appendChild(dots);
      indicator.appendChild(avatar);
      indicator.appendChild(content);
      thread.appendChild(indicator);
      if (scrollContainer) {
        scrollContainer.scrollTop = scrollContainer.scrollHeight;
      }
      return indicator;
      };

      const removeTypingIndicator = (indicator) => {
      if (indicator && indicator.parentNode) {
        indicator.parentNode.removeChild(indicator);
      }
      };

      const ensurePosts = async () => {
        if (state.posts.length) return;
        try {
          const postsResponse = await fetch('/api/posts.json');
          if (postsResponse.ok) {
            state.posts = await postsResponse.json();
          }
        } catch (error) {
          console.warn('Failed to load posts.', error);
        }
      };

      const ensureTalks = async () => {
        if (state.talks.length) return;
        try {
          const talksResponse = await fetch('/api/talks.json');
          if (talksResponse.ok) {
            state.talks = await talksResponse.json();
          }
        } catch (error) {
          console.warn('Failed to load talks.', error);
        }
      };

      const detectIntent = (normalized) => {
        if (includesAny(normalized, ['talk', 'talks', 'speaking', 'speaker', 'conference', 'recent talks'])) {
          return 'talks';
        }
        if (includesAny(normalized, [
          'blog',
          'post',
          'posts',
          'writing',
          'article',
          'articles',
          'read next',
          'what should i read',
          'what should i read next',
          'recommend',
        ])) {
          return 'posts';
        }
        return null;
      };

      const handleSubmit = (prompt) => {
        if (!prompt) return;
        const userNode = document.createElement('div');
        userNode.appendChild(createParagraph(prompt));
        addMessage('user', userNode);
        input.value = '';

        const typingIndicator = showTypingIndicator();
        window.setTimeout(async () => {
          const normalized = prompt.toLowerCase();
          const intent = detectIntent(normalized);
          if (intent === 'talks') {
            await ensureTalks();
          }
          if (intent === 'posts') {
            await ensurePosts();
          }
          removeTypingIndicator(typingIndicator);
          const response = buildResponse(prompt);
          renderAssistantResponse(response);
        }, 200);
      };

      form.addEventListener('submit', (event) => {
        event.preventDefault();
        handleSubmit(input.value.trim());
      });

      thread.addEventListener('click', (event) => {
        const target = event.target;
        if (!(target instanceof HTMLElement)) return;
        const button = target.closest('button[data-prompt]');
        if (button instanceof HTMLButtonElement) {
          handleSubmit(button.dataset.prompt || '');
        }
      });

      if (!window.__portfolioChatDocBound) {
        window.__portfolioChatDocBound = true;
        document.addEventListener('click', (event) => {
          const target = event.target;
          if (!(target instanceof HTMLElement)) return;
          const link = target.closest('a[href*="?prompt="]');
          if (!(link instanceof HTMLAnchorElement)) return;
          if (window.location.pathname !== link.pathname) return;
          event.preventDefault();
          const params = new URLSearchParams(link.search);
          const prompt = params.get('prompt');
          if (prompt) {
            history.pushState({}, '', link.href);
            handleSubmit(prompt);
          }
        });

        window.addEventListener('popstate', () => {
          const params = new URLSearchParams(window.location.search);
          const prompt = params.get('prompt');
          if (prompt) {
            handleSubmit(prompt);
          }
        });
      }

      if (micButton && micButton.dataset.bound !== 'true') {
        micButton.dataset.bound = 'true';
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        if ('brave' in navigator) {
          micButton.style.display = 'none';
          return;
        }
        if (SpeechRecognition) {
          const recognition = new SpeechRecognition();
          recognition.lang = 'en-US';
          recognition.interimResults = false;
          recognition.maxAlternatives = 1;
          recognition.continuous = false;
          let isListening = false;

          micButton.addEventListener('click', () => {
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            if (window.location.protocol !== 'https:' && !isLocalhost) {
              addAssistantNote('Voice input requires HTTPS. Open the site over HTTPS and try again.');
              return;
            }
            if (isListening) {
              recognition.stop();
              return;
            }
            if (navigator.permissions && navigator.permissions.query) {
              navigator.permissions.query({ name: 'microphone' }).then((status) => {
                if (status.state === 'denied') {
                  addAssistantNote('Microphone access is blocked in this browser. Allow microphone permissions and try again.');
                }
              }).catch(() => {
                // Ignore permission query failures; SpeechRecognition will emit errors if blocked.
              });
            }
            try {
              recognition.start();
            } catch (error) {
              addAssistantNote('Voice input could not start. Please try again.');
            }
          });

          recognition.addEventListener('start', () => {
            micButton.setAttribute('data-listening', 'true');
            isListening = true;
          });

          recognition.addEventListener('end', () => {
            micButton.removeAttribute('data-listening');
            isListening = false;
          });

          recognition.addEventListener('result', (event) => {
            const firstResult = event.results && event.results[0] && event.results[0][0];
            const transcript = firstResult ? firstResult.transcript.trim() : '';
            if (!transcript) return;
            input.value = transcript;
            handleSubmit(transcript);
          });

          recognition.addEventListener('nomatch', () => {
            addAssistantNote('I did not catch that. Try again or type your question.');
          });

          recognition.addEventListener('error', (event) => {
            micButton.removeAttribute('data-listening');
            const reason = event && event.error ? ` (${event.error})` : '';
            if (event && event.error === 'network') {
              addAssistantNote('Voice input failed (network). Brave often blocks the speech service. Try disabling Shields for this site and allow the microphone, then reload.');
              return;
            }
            addAssistantNote(`Voice input failed${reason}. Check microphone permissions or try Chrome.`);
          });
        } else {
          micButton.addEventListener('click', () => {
            alert('Voice input is not supported in this browser.');
          });
        }
      }

      const boot = () => {
        const params = new URLSearchParams(window.location.search);
        const prompt = params.get('prompt');
        if (prompt) {
          handleSubmit(prompt);
        }
        input.focus();
      };

      boot();
    };

    window.addEventListener('DOMContentLoaded', setupChat);
    document.addEventListener('astro:page-load', setupChat);
  </script>
</RootLayout>
